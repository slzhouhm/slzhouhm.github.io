<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://slzhouhm.github.io/atom.xml" rel="self"/>
  
  <link href="https://slzhouhm.github.io/"/>
  <updated>2022-01-17T15:33:18.885Z</updated>
  <id>https://slzhouhm.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://slzhouhm.github.io/2022/01/17/hello-world/"/>
    <id>https://slzhouhm.github.io/2022/01/17/hello-world/</id>
    <published>2022-01-17T15:33:18.885Z</published>
    <updated>2022-01-17T15:33:18.885Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法题解1</title>
    <link href="https://slzhouhm.github.io/2022/01/17/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/SFTI001/"/>
    <id>https://slzhouhm.github.io/2022/01/17/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/SFTI001/</id>
    <published>2022-01-17T15:33:18.885Z</published>
    <updated>2022-01-17T15:33:18.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题解"><a class="markdownIt-Anchor" href="#算法题解"></a> 算法题解</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题解&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法题解&quot;&gt;&lt;/a&gt; 算法题解&lt;/h1&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very </summary>
      
    
    
    
    <category term="算法题解" scheme="https://slzhouhm.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法题解,面试" scheme="https://slzhouhm.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用python快速执行linux命令---sh库</title>
    <link href="https://slzhouhm.github.io/2022/01/13/Python/sh%E5%BA%93/%E4%BD%BF%E7%94%A8python%E5%BF%AB%E9%80%9F%E6%89%A7%E8%A1%8Clinux%E5%91%BD%E4%BB%A4---sh%E5%BA%93/"/>
    <id>https://slzhouhm.github.io/2022/01/13/Python/sh%E5%BA%93/%E4%BD%BF%E7%94%A8python%E5%BF%AB%E9%80%9F%E6%89%A7%E8%A1%8Clinux%E5%91%BD%E4%BB%A4---sh%E5%BA%93/</id>
    <published>2022-01-13T23:51:40.000Z</published>
    <updated>2022-01-17T15:33:18.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介及用法"><a class="markdownIt-Anchor" href="#简介及用法"></a> 简介及用法</h1><h2 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1. 安装</h2><ul><li>pip安装方式: pip install sh</li><li>下载安装包安装: <a href="https://pypi.org/project/sh/">https://pypi.org/project/sh/</a></li></ul><h2 id="2-完整的文档地址"><a class="markdownIt-Anchor" href="#2-完整的文档地址"></a> 2. 完整的文档地址</h2><ul><li><a href="https://pypi.org/project/sh/">https://pypi.org/project/sh/</a></li></ul><ol start="3"><li>sh依赖于各种Unix系统调用，仅适用于类Unix操作系统-Linux、macOS、BSD等，不支持Windows。</li></ol><h2 id="3-常见的使用方法"><a class="markdownIt-Anchor" href="#3-常见的使用方法"></a> 3. 常见的使用方法</h2><h3 id="31-传递参数"><a class="markdownIt-Anchor" href="#31-传递参数"></a> 3.1 传递参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line">sh.ls(<span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, color=<span class="string">&quot;never&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> tar</span><br><span class="line"><span class="comment"># 正确的：</span></span><br><span class="line">tar(<span class="string">&quot;cvf&quot;</span>, <span class="string">&quot;/tmp/test.tar&quot;</span>, <span class="string">&quot;/root/test_dir&quot;</span>)</span><br><span class="line"><span class="comment"># 失败的：</span></span><br><span class="line">tar(<span class="string">&quot;cvf /tmp/test.tar /root/test_dir&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数</span></span><br><span class="line"><span class="comment"># sh 支持短格式 -a 和 长格式 --arg参数作为关键字参数</span></span><br><span class="line"><span class="comment"># eg: curl http://duckduckgo.com/ -o page.html --silent</span></span><br><span class="line">curl(<span class="string">&quot;http://duckduckgo.com/&quot;</span>, o=<span class="string">&quot;page.html&quot;</span>, silent=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">curl(<span class="string">&quot;http://duckduckgo.com/&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;page.html&quot;</span>, <span class="string">&quot;--silent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg: adduser amoffat --system --shell=/bin/bash --no-create-home</span></span><br><span class="line">adduser(<span class="string">&quot;amoffat&quot;</span>, system=<span class="literal">True</span>, shell=<span class="string">&quot;/bin/bash&quot;</span>, no_create_home=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">adduser(<span class="string">&quot;amoffat&quot;</span>, <span class="string">&quot;--system&quot;</span>, <span class="string">&quot;--shell&quot;</span>, <span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;--no-create-home&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="32-退出码和异常"><a class="markdownIt-Anchor" href="#32-退出码和异常"></a> 3.2 退出码和异常</h3><ul><li>正常进程以退出代码 0 退出。获取方式: RunningCommand.exit_code</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> ls</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(ls(<span class="string">&quot;/some/non-existant/folder&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> ErrorReturnCode_2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;folder doesn&#x27;t exist!&quot;</span>)</span><br><span class="line">    create_the_folder()</span><br><span class="line"><span class="keyword">except</span> ErrorReturnCode:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置返回码</span></span><br><span class="line"><span class="keyword">import</span> sh</span><br><span class="line">sh.weird_program(_ok_code=[<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><h4 id="321-信号"><a class="markdownIt-Anchor" href="#321-信号"></a> 3.2.1 信号</h4><ul><li>进程从信号终止时，就会引发信号。在这种情况下引发的异常是SignalException，它是ErrorReturnCode的子类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    p = sh.sleep(<span class="number">3</span>, _bg=<span class="literal">True</span>)</span><br><span class="line">    p.kill()</span><br><span class="line"><span class="keyword">except</span> sh.SignalException_SIGKILL:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;killed&quot;</span>)</span><br><span class="line"><span class="comment"># 可以使用数字或信号名称来捕获SignalException。例如，以下两个异常类是等价的：</span></span><br><span class="line"><span class="keyword">assert</span> sh.SignalException_SIGKILL == sh.SignalException_9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当命令指定非空_timeout并且命令超时时引发：</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sh.sleep(<span class="number">10</span>, _timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> sh.TimeoutException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;we timed out, as expected&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当您为RunningCommand.wait(timeout=None)指定超时时也会引发：</span></span><br><span class="line">p = sh.sleep(<span class="number">10</span>, _bg=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    p.wait(timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> sh.TimeoutException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;we timed out waiting&quot;</span>)</span><br><span class="line">    p.kill()</span><br></pre></td></tr></table></figure><h3 id="34-重定向"><a class="markdownIt-Anchor" href="#34-重定向"></a> 3.4 重定向</h3><ul><li>sh 可以使用_out和_err特殊 kwargs将进程的 STDOUT 和 STDERR 重定向到许多不同类型的目标。</li></ul><h4 id="341-文件名"><a class="markdownIt-Anchor" href="#341-文件名"></a> 3.4.1  文件名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果使用字符串，则假定它是文件名。文件名以“wb”打开，表示截断写入和二进制模式。</span></span><br><span class="line"><span class="keyword">import</span> sh</span><br><span class="line">sh.ifconfig(_out=<span class="string">&quot;/tmp/interfaces&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加</span></span><br><span class="line">h = <span class="built_in">open</span>(<span class="string">&quot;/tmp/output&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">sh.ls(<span class="string">&quot;/dir1&quot;</span>, _out=h)</span><br><span class="line">sh.ls(<span class="string">&quot;/dir2&quot;</span>, _out=h)</span><br></pre></td></tr></table></figure><h4 id="342-类文件对象"><a class="markdownIt-Anchor" href="#342-类文件对象"></a> 3.4.2 类文件对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还可以使用任何支持的对象.write(data)，例如 io.StringIO：</span></span><br><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">buf = StringIO()</span><br><span class="line">sh.ifconfig(_out=buf)</span><br><span class="line"><span class="built_in">print</span>(buf.getvalue())</span><br></pre></td></tr></table></figure><h4 id="343-函数回调"><a class="markdownIt-Anchor" href="#343-函数回调"></a> 3.4.3 函数回调</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回调函数也可以用作目标。该函数必须符合以下三个签名之一：</span></span><br><span class="line"><span class="comment"># fn（数据）</span></span><br><span class="line"><span class="comment"># 该函数仅从进程中获取数据块。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fn（数据，标准输入队列）</span></span><br><span class="line"><span class="comment"># 除了前面的签名之外，该函数还接受一个 queue.Queue，它可用于以编程方式与进程通信。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fn（数据、标准输入队列、进程）</span></span><br><span class="line"><span class="comment"># 除了前面的签名之外，该函数还接受了 weakref.weakrefOProc对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合_bg=True ， sh 可以通过将可调用函数传递给_out和/或_err来使用回调来增量处理输出。将为您的命令输出的每一行（或块）数据调用此可调用对象：</span></span><br><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> tail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_output</span>(<span class="params">line</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">p = tail(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;/var/log/some_log_file.log&quot;</span>, _out=process_output, _bg=<span class="literal">True</span>)</span><br><span class="line">p.wait()</span><br><span class="line"><span class="comment"># 要控制回调是接收行还是块，请使用 _out_bufsize。要“退出”你的回调，只需 return True。这告诉命令不要再调用你的回调了。</span></span><br><span class="line"><span class="comment"># 返回True不会杀死进程，它只会阻止回调被再次调用。有关如何从回调中终止进程的信息，请参阅交互式回调。</span></span><br></pre></td></tr></table></figure><h3 id="35-异步执行"><a class="markdownIt-Anchor" href="#35-异步执行"></a> 3.5 异步执行</h3><ul><li>sh 提供了非阻塞的方式运行命令和获取输出的方法。</li></ul><h4 id="351-增量迭代"><a class="markdownIt-Anchor" href="#351-增量迭代"></a> 3.5.1 增量迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> tail</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> tail(<span class="string">&quot;f&quot;</span>, <span class="string">&quot;/root/123.log&quot;</span>, _<span class="built_in">iter</span>=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><ul><li>需要一个完全非阻塞的迭代器，请使用_iter_noblock。 如果当前迭代会阻塞， errno.EWOULDBLOCK将被返回, 否则你会像往常一样收到一大块输出。</li></ul><h4 id="352-后台进程"><a class="markdownIt-Anchor" href="#352-后台进程"></a> 3.5.2 后台进程</h4><ul><li>可以使用_bg=True将其至于后台</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># blocks</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;... 3 senconds later&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># doesn’t block</span></span><br><span class="line">p = sleep(<span class="number">1</span>, _bg=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;print immediately!&quot;</span>)</span><br><span class="line">p.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;... and 3 senconds later&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3521-输出回调"><a class="markdownIt-Anchor" href="#3521-输出回调"></a> 3.5.2.1 输出回调</h4><ul><li>结合_bg=True, sh 可以通过将可调用函数传递给_out和/或_err来使用回调来增量处理输出。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> tail</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_output</span>(<span class="params">line</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line">p = tail(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;/var/123.log&quot;</span>, _out=process_output, _bg=<span class="literal">True</span>)</span><br><span class="line">p.wait()</span><br></pre></td></tr></table></figure><ul><li>要控制回调是接收还是块，请使用_out_buffsize. 要退出回调，只需要return True。</li><li>返回True不会杀死进程， 它只会阻止回调被再次调用。</li></ul><h4 id="3522-交互式回调"><a class="markdownIt-Anchor" href="#3522-交互式回调"></a> 3.5.2.2 交互式回调</h4><ul><li>命令可以通过特定的回调签名以交互方式与底层进程通信通过 sh 启动的每个命令都有一个内部 STDIN queue.Queue ，可以从回调中使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interact</span>(<span class="params">line, stdin</span>):</span></span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">&quot;What... is the air-speed velocity of an unladen swallow?&quot;</span>:</span><br><span class="line">        stdin.put(<span class="string">&quot;What do you mean? An African or European swallow?&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> line == <span class="string">&quot;Huh? I... I don&#x27;t know that....AAAAGHHHHHH&quot;</span>:</span><br><span class="line">        cross_bridge()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stdin.put(<span class="string">&quot;I don&#x27;t know....AAGGHHHHH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">p = sh.bridgekeeper(_out=interact, _bg=<span class="literal">True</span>)</span><br><span class="line">p.wait()</span><br></pre></td></tr></table></figure><ul><li>还可以通过添加第三个参数来接收进程对象，从回调中终止或终止您的进程（或发送任何信号，真的）：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_output</span>(<span class="params">line, stdin, process</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;ERROR&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">        process.kill()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">p = tail(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;/var/log/some_log_file.log&quot;</span>, _out=process_output, _bg=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>上面的代码将运行，打印行，some_log_file.log直到单词&quot;ERROR&quot;出现在一行中，此时尾部进程将被终止，脚本将结束。</li><li>也可以使用RunningCommand.terminate()发送 SIGTERM 或 RunningCommand.signal()发送一般信号。</li><li>也可以使用RunningCommand.terminate()发送 SIGTERM 或 RunningCommand.signal()发送一般信号。</li></ul><h4 id="3523-完成回调"><a class="markdownIt-Anchor" href="#3523-完成回调"></a> 3.5.2.3 完成回调</h4><ul><li>进程退出时调用的完成回调，通常（通过成功或错误退出代码）或通过信号。它总是被调用。</li><li>这是一个使用_done创建多进程池的示例，其中一次 sh.your_parallel_command并发执行不超过 10 个：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line">pool = Semaphore(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">done</span>(<span class="params">cmd, success, exit_code</span>):</span></span><br><span class="line">    pool.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_thing</span>(<span class="params">arg</span>):</span></span><br><span class="line">    pool.acquire()</span><br><span class="line">    <span class="keyword">return</span> sh.your_parallel_command(arg, _bg=<span class="literal">True</span>, _done=done)</span><br><span class="line"></span><br><span class="line">procs = []</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    procs.append(do_thing(arg))</span><br><span class="line"></span><br><span class="line"><span class="comment"># essentially a join</span></span><br><span class="line">[p.wait() <span class="keyword">for</span> p <span class="keyword">in</span> procs]</span><br></pre></td></tr></table></figure><h3 id="35-备份"><a class="markdownIt-Anchor" href="#35-备份"></a> 3.5 备份</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> _ls</span><br><span class="line"></span><br><span class="line">ls = ls.bake(<span class="string">&quot;-la&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ls)   <span class="comment"># &quot;/usr/bin/ls -la&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ls(<span class="string">&quot;/&quot;</span>)) <span class="comment"># 即 ls -la /</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a1 = ssh(<span class="string">&quot;server1.com&quot;</span>, <span class="string">&quot;-p 1393&quot;</span>, <span class="string">&quot;whoami&quot;</span>)</span><br><span class="line"></span><br><span class="line">server1 = ssh.bake(<span class="string">&quot;server.com&quot;</span>, p=<span class="number">1393</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(server1)</span><br><span class="line"></span><br><span class="line">a2 = server1.whoami()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(a1 == a2)    <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(server1.tail(<span class="string">&quot;/var/log/dumb_daemon.log&quot;</span>, n=<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h3 id="36-管道"><a class="markdownIt-Anchor" href="#36-管道"></a> 3.6 管道</h3><h4 id="361-基本的"><a class="markdownIt-Anchor" href="#361-基本的"></a> 3.6.1 基本的</h4><ul><li>Bash 风格的管道是使用函数组合来执行的。只需将一个命令作为输入传递给另一个，sh 会将内部命令的输出发送到外部命令的输入：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sort(du(glob(<span class="string">&quot;*&quot;</span>), <span class="string">&quot;-sb&quot;</span>), <span class="string">&quot;-rn&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wc(ls(<span class="string">&quot;/etc&quot;</span>, <span class="string">&quot;-1&quot;</span>), <span class="string">&quot;-l&quot;</span>))</span><br></pre></td></tr></table></figure><ul><li>这个基本管道不会异步传输数据；内部命令阻塞，直到完成，然后将其数据发送到外部命令。</li></ul><h4 id="362-先进的"><a class="markdownIt-Anchor" href="#362-先进的"></a> 3.6.2 先进的</h4><ul><li>对于需要并行的命令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> tr(tail(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;test.log&quot;</span>, _piped=<span class="literal">True</span>), <span class="string">&quot;[:upper:]&quot;</span>, <span class="string">&quot;[:lower:]&quot;</span>, _<span class="built_in">iter</span>=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment"># 这通过告诉它正在管道中使用，并且它应该将其输出逐行发送到. 默认情况下，_piped发送 STDOUT，但您可以通过使用轻松使其发送 STDERRtail -ftr_piped=&quot;err&quot;</span></span><br></pre></td></tr></table></figure><h3 id="37-子命令"><a class="markdownIt-Anchor" href="#37-子命令"></a> 3.7 子命令</h3><ul><li>许多命令都有自己的命令子集，比如： git(branch，checkout), svn(update, status), and sudo (其中sudo后的命令都被成为子集)</li><li>sh 通过属性访问处理子命令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> git, sudo</span><br><span class="line"></span><br><span class="line"><span class="comment"># resolves to &quot;git branch -v&quot;</span></span><br><span class="line"><span class="built_in">print</span>(git.branch(<span class="string">&quot;-v&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(git(<span class="string">&quot;branch&quot;</span>, <span class="string">&quot;-v&quot;</span>)) <span class="comment"># the same command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># resolves to &quot;sudo /bin/ls /root&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sudo.ls(<span class="string">&quot;/root&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(sudo(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;/root&quot;</span>)) <span class="comment"># the same command</span></span><br></pre></td></tr></table></figure><h3 id="38-默认参数"><a class="markdownIt-Anchor" href="#38-默认参数"></a> 3.8 默认参数</h3><ul><li>覆盖通过sh启动的所有命令的默认参数。<ul><li>方法一:</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有命令的输出汇总到io.StingIO缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">buf = StringIO()</span><br><span class="line"></span><br><span class="line">sh.ls(<span class="string">&quot;/&quot;</span>, _out=buf)</span><br><span class="line">sh.whoami(_out=buf)</span><br><span class="line">sh.ps(<span class="string">&quot;auxwf&quot;</span>, _out=buf)</span><br></pre></td></tr></table></figure><pre><code>* 方法二:</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">buf = StringIO()</span><br><span class="line">sh2 = sh(_out=buf)</span><br><span class="line"></span><br><span class="line">sh2.ls(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">sh2.whoami()</span><br><span class="line">sh2.ps(<span class="string">&quot;auxwf&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>亦可以导入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">buf = StringIO()</span><br><span class="line">sh2 = sh(_out=buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sh2 <span class="keyword">import</span> ls, whoami, ps</span><br><span class="line"></span><br><span class="line">ls(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">whoami()</span><br><span class="line">ps(<span class="string">&quot;auxwf&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="39-环境"><a class="markdownIt-Anchor" href="#39-环境"></a> 3.9 环境</h3><ul><li>_env完全替换了进程的环境。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"></span><br><span class="line">sh.google_chrome(_env=&#123;<span class="string">&quot;SOCKS_SERVER&quot;</span>: <span class="string">&quot;localhost:1234&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>引用现有环境之外的进程添加新环境变量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sh</span><br><span class="line"></span><br><span class="line">new_env = os.environ.copy()</span><br><span class="line">new_env[<span class="string">&quot;SOCKS_SERVER&quot;</span>] = <span class="string">&quot;localhost:1234&quot;</span></span><br><span class="line">sh.google_chrome(_env=new_env)</span><br></pre></td></tr></table></figure><h3 id="310-通过stdin输入"><a class="markdownIt-Anchor" href="#310-通过stdin输入"></a> 3.10 通过STDIN输入</h3><ul><li>STDIN通过使用命令的_in直接发送到进程<br />print(cat(_in=“test”))</li><li>任何从STDIN获取输入的命令都可以这样使用<br />print(tr(&quot;[:lower:]&quot;, “[:upper:]”, _in=“sh is awesome”))</li><li>除了字符串，还可以使用文件对象， a queue.Queue 或任何可迭代对象（列表、集合、字典等）：<br />stdin = [“sh”, “is”, “awesome”]<br />out = tr(&quot;[:lower:]&quot;, “[:upper:]”, _in=stdin)<br />如果使用队列，可以使用None</li></ul><h3 id="311-with-contexts"><a class="markdownIt-Anchor" href="#311-with-contexts"></a> 3.11 ‘With’ Contexts</h3><ul><li>命令可以在 Python with上下文中运行。使用它的流行命令可能是sudoor fakeroot</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> sh.contrib.sudo:</span><br><span class="line">    <span class="built_in">print</span>(ls(<span class="string">&quot;/root&quot;</span>))</span><br></pre></td></tr></table></figure><ul><li>如果您需要在带有上下文的环境中运行命令并传入参数，例如，使用 sudo 指定 -p 提示符，</li><li>则需要使用_with=True这让命令知道它是从带有上下文的环境中运行的，所以它可以正常运行：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> sh.contrib.sudo(k=<span class="literal">True</span>, _<span class="keyword">with</span>=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(ls(<span class="string">&quot;/root&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介及用法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介及用法&quot;&gt;&lt;/a&gt; 简介及用法&lt;/h1&gt;
&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-安装&quot;&gt;&lt;/a&gt; 1. 安装</summary>
      
    
    
    
    <category term="python" scheme="https://slzhouhm.github.io/categories/python/"/>
    
    <category term="sh" scheme="https://slzhouhm.github.io/categories/python/sh/"/>
    
    
    <category term="python" scheme="https://slzhouhm.github.io/tags/python/"/>
    
    <category term="sh" scheme="https://slzhouhm.github.io/tags/sh/"/>
    
    <category term="linux" scheme="https://slzhouhm.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>我的样例</title>
    <link href="https://slzhouhm.github.io/2021/12/31/%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/"/>
    <id>https://slzhouhm.github.io/2021/12/31/%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-12-31T18:56:58.000Z</published>
    <updated>2022-01-17T15:33:18.885Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://blog.plcent.com/2019/11/05/hexo-theme-pure/">https://blog.plcent.com/2019/11/05/hexo-theme-pure/</a></li><li><a href="https://www.dazhuanlan.com/simida/topics/1567142">https://www.dazhuanlan.com/simida/topics/1567142</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.plcent.com/2019/11/05/hexo-theme-pure/&quot;&gt;https://blog.plcent.com/2019/11/05/hexo-theme-pure/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h</summary>
      
    
    
    
    <category term="A" scheme="https://slzhouhm.github.io/categories/A/"/>
    
    <category term="a" scheme="https://slzhouhm.github.io/categories/A/a/"/>
    
    <category term="B" scheme="https://slzhouhm.github.io/categories/A/a/B/"/>
    
    <category term="b" scheme="https://slzhouhm.github.io/categories/A/a/B/b/"/>
    
    
    <category term="tag1" scheme="https://slzhouhm.github.io/tags/tag1/"/>
    
    <category term="tag2" scheme="https://slzhouhm.github.io/tags/tag2/"/>
    
    <category term="tag3" scheme="https://slzhouhm.github.io/tags/tag3/"/>
    
  </entry>
  
</feed>
